#define PI 3.14159265359
#define TWO_PI 6.28318530718

float rand(float x) {
    return fract(sin(x + 231.23 * 2451.71) * 5629.643);
}
float rand(vec2 st) {
    return fract(sin(dot(st.xy + 75.3, vec2(2561, 6922))) * 7623.);
}
float rand(vec3 st) {
    return fract(sin(dot(st.xyz + 92.6, vec3(2561, 6922, 9813))) * 5223.);
}
float rand(vec4 st) {
    return fract(sin(dot(st.xyzw + 93.645, vec4(2561, 6922, 9813, 6412))) * 5223.);
}

float when_eq(float x, float y) {
  return 1.0 - abs(sign(x - y));
}
float when_neq(float x, float y) {
  return abs(sign(x - y));
}
float when_gt(float x, float y) {
  return max(sign(x - y), 0.0);
}
float when_lt(float x, float y) {
  return max(sign(y - x), 0.0);
}
float when_ge(float x, float y) {
  return 1.0 - when_lt(x, y);
}
float when_le(float x, float y) {
  return 1.0 - when_gt(x, y);
}

vec2 when_eq(vec2 x, vec2 y) {
  return 1.0 - abs(sign(x - y));
}
vec2 when_neq(vec2 x, vec2 y) {
  return abs(sign(x - y));
}
vec2 when_gt(vec2 x, vec2 y) {
  return max(sign(x - y), 0.0);
}
vec2 when_lt(vec2 x, vec2 y) {
  return max(sign(y - x), 0.0);
}
vec2 when_ge(vec2 x, vec2 y) {
  return 1.0 - when_lt(x, y);
}
vec2 when_le(vec2 x, vec2 y) {
  return 1.0 - when_gt(x, y);
}

vec3 when_eq(vec3 x, vec3 y) {
  return 1.0 - abs(sign(x - y));
}
vec3 when_neq(vec3 x, vec3 y) {
  return abs(sign(x - y));
}
vec3 when_gt(vec3 x, vec3 y) {
  return max(sign(x - y), 0.0);
}
vec3 when_lt(vec3 x, vec3 y) {
  return max(sign(y - x), 0.0);
}
vec3 when_ge(vec3 x, vec3 y) {
  return 1.0 - when_lt(x, y);
}
vec3 when_le(vec3 x, vec3 y) {
  return 1.0 - when_gt(x, y);
}

float between(float min, float max, float x) {
  return (1.0 - step(max, x)) * step(min, x);
}
float or(float a, float b) {
  return min(a + b, 1.0);
}
float and(float a, float b) {
  return a * b;
}

float saturate(float v) {
  return clamp(v,0.0,1.0);
}

float norm(float x, float minRange, float maxRange) {
  return (x - minRange) / (maxRange - minRange);
}

// Hack: to prevent cocos removing chunk functions
// DO NOT TRY THIS ON ACTUAL PRODUCTION CODE
void useAllSnakeLib() {
  norm(1., 1., 1.);
  saturate(1.);
  and(1., 1.);
  or(1., 1.);
  between(1., 1., 1.);

  rand(1.);
  rand(vec2(1., 1.));
  rand(vec3(1., 1., 1.));
  rand(vec4(1., 1., 1., 1.));

  when_eq(1., 1.);
  when_neq(1., 1.);
  when_gt(1., 1.);
  when_lt(1., 1.);
  when_ge(1., 1.);
  when_le(1., 1.);

  when_eq(vec2(1., 1.), vec2(1., 1.));
  when_neq(vec2(1., 1.), vec2(1., 1.));
  when_gt(vec2(1., 1.), vec2(1., 1.));
  when_lt(vec2(1., 1.), vec2(1., 1.));
  when_ge(vec2(1., 1.), vec2(1., 1.));
  when_le(vec2(1., 1.), vec2(1., 1.));

  when_eq(vec3(1., 1., 1.), vec3(1., 1., 1.));
  when_neq(vec3(1., 1., 1.), vec3(1., 1., 1.));
  when_gt(vec3(1., 1., 1.), vec3(1., 1., 1.));
  when_lt(vec3(1., 1., 1.), vec3(1., 1., 1.));
  when_ge(vec3(1., 1., 1.), vec3(1., 1., 1.));
  when_le(vec3(1., 1., 1.), vec3(1., 1., 1.));
}
